# C++ コーディングスキルテスト 追加設問候補

実務のC++開発で重要な知識をカバーする追加設問候補です。

## 基礎レベル (Beginner)

### 設問1: 配列とポインタの関係
**問題:** 配列名を関数の引数として渡した場合、どのように扱われますか？
- A) 配列全体のコピーが渡される
- B) 配列の先頭要素へのポインタが渡される
- C) 配列のサイズ情報も一緒に渡される
- D) コンパイルエラーになる

**正解:** B  
**解説:** C++では配列名は配列の先頭要素へのポインタに自動変換されます（配列のdecay）。そのため、関数内では元の配列のサイズ情報は失われます。

### 設問2: 関数オーバーロード
**問題:** 以下のうち、関数オーバーロードの判断基準として**使用されない**ものはどれですか？
- A) 引数の型
- B) 引数の個数
- C) 戻り値の型
- D) const修飾子の有無

**正解:** C  
**解説:** C++では戻り値の型だけが異なる関数はオーバーロードできません。引数の型、個数、const修飾子などで区別されます。

### 設問3: 演算子オーバーロード
**問題:** `operator+` を定義する際、一般的に推奨される実装方法はどれですか？
- A) メンバ関数として定義し、左オペランドを変更する
- B) メンバ関数として定義し、新しいオブジェクトを返す
- C) 非メンバ関数として定義し、新しいオブジェクトを返す
- D) static関数として定義する

**正解:** C  
**解説:** `operator+` は通常、非メンバ関数として定義し、両オペランドを変更せずに新しいオブジェクトを返すのが一般的です。これにより `a + b` と `1.0 + a`（型変換を伴う）の両方が可能になります。

### 設問4: インクルードガードの現代的な方法
**問題:** `#ifndef`/`#define`/`#endif` に代わる、より簡潔なインクルードガードの方法はどれですか？
- A) `#once`
- B) `#pragma once`
- C) `#include_once`
- D) `#guard`

**正解:** B  
**解説:** `#pragma once` はコンパイラ依存ですが、多くの現代的なコンパイラでサポートされており、伝統的なインクルードガードより簡潔で間違いが少ないです。

## 中級レベル (Intermediate)

### 設問5: 仮想関数の基本
**問題:** 仮想関数を持つクラスで、派生クラスのオブジェクトを基底クラスのポインタで削除する際に重要なのは何ですか？
- A) 仮想コンストラクタ
- B) 仮想デストラクタ
- C) 純粋仮想関数
- D) 仮想継承

**正解:** B  
**解説:** 基底クラスのデストラクタが仮想でないと、派生クラスのデストラクタが呼ばれずリソースリークの原因となります。

### 設問6: 継承のアクセス制御
**問題:** `class Derived : private Base` で継承した場合、Baseのpublicメンバは Derivedクラス内でどのようにアクセスできますか？
- A) publicとしてアクセス可能
- B) protectedとしてアクセス可能
- C) privateとしてアクセス可能
- D) アクセス不可

**正解:** C  
**解説:** private継承では、基底クラスのpublic/protectedメンバは派生クラス内でprivateとしてアクセスできますが、派生クラスの外部からはアクセスできません。

### 設問7: メンバ初期化リスト
**問題:** メンバ初期化リストを**必ず**使用しなければならない場合はどれですか？
- A) intメンバの初期化
- B) constメンバの初期化
- C) staticメンバの初期化
- D) pointerメンバの初期化

**正解:** B  
**解説:** constメンバ、参照メンバ、デフォルトコンストラクタを持たないクラスのメンバは、メンバ初期化リストでの初期化が必須です。

### 設問8: virtual関数の動的束縛
**問題:** 以下のコードで出力される結果はどれですか？
```cpp
class Base {
public:
    virtual void print() { cout << "Base"; }
};
class Derived : public Base {
public:
    void print() override { cout << "Derived"; }
};
Base* ptr = new Derived();
ptr->print();
```
- A) Base
- B) Derived
- C) コンパイルエラー
- D) 未定義動作

**正解:** B  
**解説:** virtual関数では実行時に実際のオブジェクトの型に基づいて適切な関数が呼ばれます（動的束縛）。

### 設問9: 静的メンバと非静的メンバ
**問題:** 静的メンバ関数について正しいのはどれですか？
- A) thisポインタを使用できる
- B) 非静的メンバ変数にアクセスできる
- C) クラスのインスタンスなしで呼び出せる
- D) virtual宣言できる

**正解:** C  
**解説:** 静的メンバ関数は特定のインスタンスに属さないため、クラス名を使って直接呼び出すことができます。thisポインタや非静的メンバには直接アクセスできません。

## 上級レベル (Advanced)

### 設問10: オブジェクトのメモリレイアウト
**問題:** 仮想関数を持つクラスのオブジェクトが通常含むものはどれですか？
- A) 仮想関数テーブル（vtable）
- B) vtableへのポインタ（vptr）
- C) 仮想関数のコード
- D) 基底クラスのコピー

**正解:** B  
**解説:** 仮想関数を持つクラスのオブジェクトは、vtableへのポインタ（vptr）を含みます。vtable自体はクラスごとに1つ存在します。

### 設問11: テンプレート特殊化
**問題:** 以下のような関数テンプレートの完全特殊化の正しい記法はどれですか？
```cpp
template<typename T>
void func(T value) { /* 汎用版 */ }
```
- A) `template<> void func<int>(int value) { /* int特殊版 */ }`
- B) `template<int> void func(int value) { /* int特殊版 */ }`
- C) `void func<int>(int value) { /* int特殊版 */ }`
- D) `specialized void func(int value) { /* int特殊版 */ }`

**正解:** A  
**解説:** 完全特殊化では `template<>` を使用し、特殊化する型を明示します。

### 設問12: constexprの評価タイミング
**問題:** `constexpr`関数について正しいのはどれですか？
- A) 常にコンパイル時に評価される
- B) コンパイル時定数の引数が与えられた場合のみ、コンパイル時に評価される可能性がある
- C) 実行時にのみ評価される
- D) インライン関数と同じ動作をする

**正解:** B  
**解説:** `constexpr`関数は、コンパイル時定数の引数が渡された場合にコンパイル時評価が可能ですが、実行時の値が渡された場合は通常の関数として実行時に実行されます。

### 設問13: SFINAEの基本概念
**問題:** SFINAE (Substitution Failure Is Not An Error) の主な用途は何ですか？
- A) コンパイル時にエラーを強制的に発生させる
- B) テンプレートの置換失敗を利用してオーバーロード解決を制御する
- C) 実行時の型情報を取得する
- D) メモリ確保の失敗を処理する

**正解:** B  
**解説:** SFINAEは、テンプレート引数の置換が失敗してもエラーにならず、単にそのオーバーロード候補から除外される仕組みです。これを利用して型特性に応じたテンプレート制御が可能になります。

### 設問14: メモリアライメントとオブジェクトサイズ
**問題:** 以下の構造体のサイズ（64bit環境、通常のアライメント）はおそらく何バイトですか？
```cpp
struct MyStruct {
    char a;     // 1 byte
    int b;      // 4 bytes  
    char c;     // 1 byte
};
```
- A) 6 bytes
- B) 8 bytes
- C) 12 bytes
- D) 16 bytes

**正解:** C  
**解説:** メンバのアライメント要求により、char aの後に3バイトのパディング、char cの後に3バイトのパディングが挿入され、合計12バイトになることが多いです。

### 設問15: 例外安全性のレベル
**問題:** 強い例外安全性（Strong Exception Safety）の保証とは何ですか？
- A) 例外が発生しないことを保証する
- B) 例外が発生してもプログラムが異常終了しない
- C) 例外が発生してもオブジェクトの状態が操作前と同じに保たれる
- D) 例外が発生してもメモリリークが発生しない

**正解:** C  
**解説:** 強い例外安全性では、操作が失敗（例外発生）した場合、オブジェクトの状態が操作開始前と同じ状態に戻ることが保証されます。

---

## 設問選択の理由

これらの設問は以下の理由で実務において重要です：

### 基礎レベル
- **配列とポインタ**: C互換性とメモリ理解の基礎
- **関数オーバーロード**: C++の多態性の基本
- **演算子オーバーロード**: C++らしいコードを書くための基礎
- **#pragma once**: 現代的なヘッダー管理

### 中級レベル  
- **仮想関数**: オブジェクト指向プログラミングの核心
- **継承**: クラス設計の基本
- **メンバ初期化リスト**: 効率的で正確な初期化
- **動的束縛**: ポリモーフィズムの仕組み理解
- **静的メンバ**: クラス設計パターンで頻出

### 上級レベル
- **vtable**: パフォーマンス最適化で重要
- **テンプレート特殊化**: ライブラリ開発で必須
- **constexpr**: 現代C++のコンパイル時プログラミング
- **SFINAE**: 高度なテンプレートプログラミング
- **メモリレイアウト**: 最適化とデバッグで重要
- **例外安全性**: 堅牢なコード設計の基礎

これらは現在の設問セットを補完し、実務でよく遭遇する重要な概念をカバーします。